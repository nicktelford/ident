package net.nicktelford.ident.rfc4122;

import net.nicktelford.ident.Clock;
import net.nicktelford.ident.clocks.SystemClock;

import java.util.concurrent.TimeUnit;

/**
 * An RFC4122 Version 1 Time-based UUID.
 * <p/>
 * This variant uses a combination of the current system time, system MAC
 * address and a monotonic clock to produce a UUID with a very low and well
 * defined probability of collision.
 * <p/>
 * The precision and accuracy of the time component of UUIDs generated by this
 * implementation is dependent on the {@link Clock} used. The
 */
public class TimeUUID extends RFC4122UUID {

    public static final short VERSION = 1;

    private static final long EPOCH_OFFSET = 0x01B21DD213814000L;

    private static final Factory FACTORY = new Factory(VERSION);

    public static TimeUUID MAX_VALUE
            = new TimeUUID(FACTORY.encodeMSB(-1), FACTORY.encodeLSB(-1));
    public static TimeUUID MIN_VALUE
            = new TimeUUID(FACTORY.encodeMSB(0), FACTORY.encodeLSB(0));

    public static TimeUUID fromUnixTime(final long timestamp) {
        return fromUnixTime(timestamp, TimeUnit.SECONDS);
    }

    public static TimeUUID fromUnixTime(final long timestamp,
                                        final short clock,
                                        final long node) {
        return fromUnixTime(timestamp, TimeUnit.SECONDS, clock, node);
    }

    public static TimeUUID fromUnixTime(final long timestamp,
                                        final TimeUnit unit) {
        return fromUUIDTime((unit.toNanos(timestamp) / 100) - EPOCH_OFFSET);
    }

    public static TimeUUID fromUnixTime(final long timestamp,
                                        final TimeUnit unit,
                                        final short clock,
                                        final long node) {
        return fromUUIDTime((unit.toNanos(timestamp) / 100) - EPOCH_OFFSET,
                            clock, node);
    }

    public static TimeUUID fromUUIDTime(final long timestamp) {
        return new TimeUUID(FACTORY.encodeMSB(timestamp), FACTORY.randomLSB());
    }

    public static TimeUUID fromUUIDTime(final long timestamp,
                                        final short clock,
                                        final long node) {
        return new TimeUUID(FACTORY.encodeMSB(timestamp),
                            FACTORY.encodeLSB(((long) clock << 48) |
                                              (node & 0xFFFFFFFFFFFFL)));
    }

    public static TimeUUID create() {
        return create(SystemClock.getInstance());
    }

    public static TimeUUID create(final Clock clock) {
        return fromUnixTime(clock.currentTimeNanos(), TimeUnit.NANOSECONDS);
    }

    TimeUUID(final long msb, final long lsb) {
        super(msb, lsb);
    }

    @Override
    public short version() {
        return VERSION;
    }

    public long unixTime() {
        return unixTime(TimeUnit.SECONDS);
    }

    public long unixTime(final TimeUnit targetUnit) {
        return targetUnit.convert(
                (timestamp() * 100) + EPOCH_OFFSET,
                TimeUnit.NANOSECONDS);
    }

    public long timestamp() {
        final long time_lo = msb >> 32;
        final long time_mid = (msb & 0xFFFF0000L) << 16;
        final long time_hi = (msb & 0x0FFF) << 48;

        return (time_hi | time_mid | time_lo);
    }

    public short clock() {
        final long clock_lo = (lsb >> 48) & 0xF;
        final long clock_hi = (lsb >> 56) & (0xF - variant().mask());
        return (short) ((clock_hi << 8) | clock_lo);
    }

    public long node() {
        return lsb & 0xFFFFFFFFFFFFL;
    }
}
